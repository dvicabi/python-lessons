# 📘 איטרטורים בפייתון – Python Iterators

## ✨ הסבר

תחשוב על איטרטור כמו מכונה שמחזירה לך כל פעם פריט אחר מתוך משהו – למשל רשימה. כשאתה עובר עם `for` על רשימה, פייתון משתמש במנגנון שנקרא **איטרטור** כדי לדעת מהו הפריט הבא.

יש שני מושגים חשובים:
- **Iterable** – כל דבר שאפשר לעבור עליו, כמו `list`, `str`, `tuple`, `dict`
- **Iterator** – האובייקט שמנהל את המעבר בפועל, זוכר איפה היינו, ויודע מה הבא בתור

## 🧠 מה נלמד בפרק הזה?

- מהו iterable ומהו iterator
- איך משתמשים ב־`iter()` ו־`next()`
- איך כותבים מחלקה משלך שתומכת באיטרציה
- למה חשוב להפעיל `StopIteration`
- איך איטרטורים משתלבים עם לולאות `for`

---

## 🔍 הסברים ודוגמאות

### 📌 מהו Iterable ומהו Iterator?
```python
my_list = [10, 20, 30]
it = iter(my_list)      # יוצר איטרטור
print(next(it))         # 10
print(next(it))         # 20
print(next(it))         # 30
✔️ iter() יוצר איטרטור.
✔️ next() שואל מהו הפריט הבא.

📌 יצירת איטרטור מותאם אישית עם מחלקה
python
Copy
Edit
class CountUpTo:
    def __init__(self, max_value):
        self.current = 1
        self.max = max_value

    def __iter__(self):
        return self

    def __next__(self):
        if self.current > self.max:
            raise StopIteration
        value = self.current
        self.current += 1
        return value

for number in CountUpTo(3):
    print(number)
✔️ יוצר איטרטור שמחזיר 1, ואז 2, ואז 3 – ואז מפסיק.

📌 דוגמה עם טקסט – כל אות במילה:
python
Copy
Edit
text = "Python"
text_iter = iter(text)

while True:
    try:
        print(next(text_iter))
    except StopIteration:
        break
✔️ StopIteration תמיד עוצר את האיטרציה – פייתון משתמש בזה בתוך for.

📌 איטרטור מותאם – הכפלה בכל צעד
python
Copy
Edit
class Doubler:
    def __init__(self, start, limit):
        self.value = start
        self.limit = limit

    def __iter__(self):
        return self

    def __next__(self):
        if self.value > self.limit:
            raise StopIteration
        current = self.value
        self.value *= 2
        return current

for num in Doubler(1, 20):
    print(num)  # 1, 2, 4, 8, 16
💡 טיפים מתקדמים
כל מחלקה שאתה בונה עם __iter__ ו־__next__ יכולה לעבוד עם for

אתה לא חייב לבנות איטרטור – אם יש לך רשימה או טקסט, זה כבר iterable

תמיד תפעיל raise StopIteration כשנגמר מה להחזיר

איטרטור טוב הוא כזה ששומר מידע – כמו מונה פנימי (current)
