# 📘 טיפוסים משתנים ולא משתנים – Mutable vs Immutable

## ✨ הסבר
יש משתנים ששומרים את הערך בזיכרון ואפשר לשנות אותם, ויש כאלה שכל שינוי יוצר עותק חדש. לדוגמה, אם נשלח מספר לפונקציה ונשנה אותו שם – זה לא ישפיע על מה שהיה מחוץ לפונקציה. אבל אם נשלח רשימה – השינויים יישמרו גם מחוץ לפונקציה. זה הבדל חשוב מאוד בתכנות.

## 🧠 מה נלמד בפרק הזה?
- ההבדל בין טיפוסים משתנים לבלתי משתנים
- אילו טיפוסים פרימיטיביים (Immutable)
- אילו טיפוסים שומרים זיכרון ומשתנים (Mutable)
- איך זה משפיע כשמעבירים לפונקציות

## 🔍 הסברים ודוגמאות

### 🔸 מה זה טיפוס בלתי ניתן לשינוי – Immutable

```python
x = 10

def add_one(num):
    num += 1
    print("Inside:", num)


add_one(x)
print("Outside:", x)  # עדיין 10
```
🔸 מה זה טיפוס שניתן לשינוי – Mutable
```python
numbers = [1, 2, 3]

def append_value(lst):
    lst.append(4)
    print("Inside:", lst)

append_value(numbers)
print("Outside:", numbers)  # משתנה גם מבחוץ
```
🔸 טבלת השוואה – טיפוסים פרימיטיביים לעומת לא
טיפוס	פרימיטיבי?	Mutable?	דוגמה
```python
int	כן	❌	x = 5
float	כן	❌	x = 3.14
str	כן	❌	s = "hi"
bool	כן	❌	b = True
tuple	כן	❌	t = (1, 2)
list	לא	✔️	l = [1, 2]
dict	לא	✔️	d = {"a": 1}
set	לא	✔️	s = {1, 2}
```

💡 טיפים מתקדמים
כל שינוי ב־Immutable יוצר אובייקט חדש בזיכרון.

טיפוס tuple הוא בלתי משתנה, אבל אם הוא כולל רשימה בפנים – הרשימה כן תשתנה.

אפשר לבדוק זהות בזיכרון עם id() כדי לראות אם באמת נוצר אובייקט חדש.

✅ בדוק את עצמך
מה יקרה אם נשנה מחרוזת בתוך פונקציה – האם המקור ישתנה?

איזו התנהגות תקרה אם נעביר מילון לפונקציה ונשנה אותו?

