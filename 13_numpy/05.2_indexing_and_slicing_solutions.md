# 📘 פתרונות – Indexing and Slicing

## 🧪 פתרונות לתרגילים

### תרגיל 1
```python
a = np.array([10, 20, 30, 40, 50])

print(a[0])      # Output: 10
print(a[-1])     # Output: 50
print(a[1:4])    # Output: [20 30 40]
```

### תרגיל 2
```python
b = np.array([[1, 2, 3],
              [4, 5, 6]])

print(b[0, 2])    # Output: 3
print(b[1])       # Output: [4 5 6]
print(b[:, 0])    # Output: [1 4]
```

### תרגיל 3
```python
c = np.array([100, 200, 300, 400, 500])

print(c[1:4])     # Output: [200 300 400]
print(c[::2])     # Output: [100 300 500]
```

### תרגיל 4
```python
d = np.array([[10, 20, 30],
              [40, 50, 60],
              [70, 80, 90]])

# אלכסון ראשי (שורה = עמודה)
print(np.array([d[i, i] for i in range(3)]))  # Output: [10 50 90]

# עמודה אחרונה
print(d[:, -1])   # Output: [30 60 90]

# תת־מטריצה: 2 שורות אחרונות, 2 עמודות ראשונות
print(d[1:, :2])
# Output:
# [[40 50]
#  [70 80]]
```

## 💬 הערות כלליות

* אינדוקס ב־NumPy מדויק ונוח – אבל דורש תשומת לב למיקום של שורה ועמודה.
* חיתוך מאפשר שליטה מוחלטת על תת־מקטעים מהמערך – כולל חיתוכים חכמים בשני צירים.
* שימוש באינדוקס שלילי שימושי במיוחד לשליפת ערכים מהסוף.

