<!-- DC_HEADER_START -->
<div align="center">

🐍 **Python Learning Series | סדרת לימודי פייתון**  
**Dvir Cabessa | דביר קבסה**  
© 2025 All Rights Reserved | כל הזכויות שמורות

</div>

---
<!-- DC_HEADER_END -->

הטבלה שלפניך מרכזת את כל דפוסי העיצוב (Design Patterns) הקלאסיים בעולם התוכנה

בצורה חכמה, ברורה וממוקדת לזיהוי ושימוש מיידי.

מטרתה לאפשר לך, כמפתח או כמרצה, לזהות בקלות כל דפוס עיצוב בתוך קוד אמיתי, להבין מתי להשתמש בו, כיצד הוא בנוי, ומהם הדגשים החשובים בעת ההטמעה שלו.

היא מושלמת ללמידה, לבחינות, להרצאות, או לפיתוח תוכנה ברמה מקצועית.

לכל דפוס תמצא בטבלה:

🔸 מתי נכון להשתמש בו – תרחיש קלאסי בעולם האמיתי.

🔸 איך לזהות אותו בקוד – סימנים שמופיעים בקוד המעידים על הדפוס.

🔸 דגשים מיוחדים – נקודות שחשוב להכיר כדי ליישם אותו נכון.

🔸 שם בעברית – תרגום ברור שמתאים לשיחה מקצועית או לימוד בעברית.
---
🔹 **שאלות אבחון מהירות לכל דפוס**
🔸 תוכל להשתמש בשאלות אלו במהלך קריאת קוד:

| DESIGN PATTERN              | שאלה לזיהוי מהיר                                                                     |
| --------------------------- | ------------------------------------------------------------------------------------ |
| **Factory Method**          | האם הקוד מחביא את המימוש של יצירת האובייקט מאחורי מתודה שמוחזרת ע"י מחלקת אב?        |
| **Abstract Factory**        | האם יש כמה משפחות של אובייקטים שקשורים זה לזה (UI, לוגיקה), ואתה יכול להחליף ביניהן? |
| **Builder**                 | האם בניית האובייקט נעשית בשלבים (כמו `builder.setX().setY()`) ולא בשורה אחת?         |
| **Prototype**               | האם נוצרים אובייקטים ע"י שיבוט של אובייקט קיים (`clone()`)?                          |
| **Singleton**               | האם יש בדיקה אם קיים כבר מופע? האם יש גישה גלובלית דרך `getInstance()`?              |
| **Adapter**                 | האם אובייקט עוטף אובייקט אחר כדי לשנות את הממשק שלו בלי לשנות את ההתנהגות?           |
| **Bridge**                  | האם קיימת הפרדה בין הגדרה של פונקציונליות (אבסטרקציה) למימוש שלה?                    |
| **Composite**               | האם אובייקטים מכילים רשימות של אובייקטים מאותו סוג (עץ)?                             |
| **Decorator**               | האם אובייקט עוטף אובייקט אחר ומוסיף לו התנהגות חדשה?                                 |
| **Facade**                  | האם קיימת מחלקה אחת שמרכזת בתוכה גישה למערכת מורכבת של מחלקות אחרות?                 |
| **Flyweight**               | האם נעשה שימוש בשיתוף אובייקטים במקום ליצור הרבה מופעים דומים?                       |
| **Proxy**                   | האם יש אובייקט מתווך שלוכד את הבקשות לאובייקט האמיתי (לוגיקה של גישה)?               |
| **Chain of Responsibility** | האם יש שרשרת של אובייקטים שמעבירה ביניהם את הבקשה עד שמישהו מטפל בה?                 |
| **Command**                 | האם הבקשה עטופה כאובייקט עצמאי שניתן להעביר, לשמור או לבטל?                          |
| **Iterator**                | האם הקוד מאפשר מעבר על אלמנטים בצורה שקופה (for-each)?                               |
| **Mediator**                | האם יש אובייקט מרכזי שמתאם את התקשורת בין רכיבים כדי למנוע קשרים ישירים ביניהם?      |
| **Memento**                 | האם נשמר המצב של אובייקט בלי לחשוף את השדות הפנימיים שלו?                            |
| **Observer**                | האם אובייקטים נרשמים כדי להתעדכן על שינויים באובייקט אחר?                            |
| **State**                   | האם ההתנהגות משתנה לפי מצב פנימי מבלי לשנות את המחלקה?                               |
| **Strategy**                | האם יש בחירה בין כמה התנהגויות (אלגוריתמים) שניתנים להחלפה?                          |
| **Template Method**         | האם האלגוריתם הכללי מוגדר במחלקה האב, וחלק מהשלבים ניתנים להתאמה במחלקת הבת?         |
| **Visitor**                 | האם אלגוריתם חיצוני מופעל על סוגים שונים של אובייקטים מבלי לשנות אותם?               |

---

🔹 **דפוסי קוד חוזרים שמאותתים על שימוש ב־Design Pattern**

| סימן בקוד                                 | דפוס חשוד               |
| ----------------------------------------- | ----------------------- |
| שימוש במתודה `clone()`                    | Prototype               |
| שימוש במתודה `getInstance()`              | Singleton               |
| מחלקה עם `createX()` בתוך מחלקת אבסטרקטית | Factory Method          |
| מתודות `add(Component c)` ו־`remove()`    | Composite               |
| מתודת `handle(request)` שממשיכה לאחרים    | Chain of Responsibility |
| ממשק אחד עם מימושים רבים שמוזרקים פנימה   | Strategy                |

---

| דפוס                  | מתי להשתמש                                                                                         | איך מזהים בקוד                                                                                   | דגשים / מאפיינים מיוחדים                                                                 | שם בעברית           |
|------------------------|-----------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|----------------------|
| Abstract Factory       | כשצריך ליצור משפחות של אובייקטים קשורים מבלי לחשוף את המימושים                                    | יצירת מחלקות שמחזירות אובייקטים לפי קטגוריה (UI, DB, OS וכו')                                  | מאפשר החלפת משפחות שלמות של אובייקטים בהתאם לקונפיגורציה אחת                           | מפעל אבסטרקטי        |
| Builder                | כשצריך לבנות אובייקט מורכב בשלבים                                                                  | בנייה בשלבים עם מתודות כמו `.setX()` ו־`.build()`                                               | מתאים לאובייקטים שיש להם הרבה פרמטרים או מבנה היררכי                                      | בונה                 |
| Factory Method         | כשרוצים לאפשר למחלקות בת להחליט איזה אובייקט ליצור                                                | מחלקת אב עם מתודה מופשטת ליצירת אובייקט, כל מחלקת בת מחזירה סוג שונה                          | מאפשר הרחבה בלי לשנות את קוד מחלקת האב                                                    | שיטת מפעל            |
| Prototype              | כשיש אובייקטים יקרים ליצירה ורוצים לשכפל אותם                                                      | שימוש ב־`clone()` או העתקה מאובייקט קיים                                                        | יעיל בזיכרון וזמן ריצה, טוב ל־Game Dev או UI Elements                                      | אבטיפוס              |
| Singleton              | כשצריך להבטיח שיש מופע אחד בלבד למחלקה מסוימת                                                     | מתודה `getInstance()` שמחזירה תמיד את אותו מופע                                                 | ניהול גישה גלובלית, זהירות מ־Thread Safety                                                | יחיד                 |
| Adapter                | כששני ממשקים לא תואמים ואתה רוצה לחבר ביניהם                                                       | מחלקה שעוטפת אובייקט קיים וממפה מתודות בין הממשקים                                              | לא משנים את הקוד הקיים – רק "מתאמים"                                                      | מתאם                 |
| Bridge                 | כשיש צורך להפריד בין האבסטרקציה למימוש שלה – מבנה גמיש יותר                                       | שתי היררכיות נפרדות: אחת לאבסטרקציה ואחת למימוש, עם קומפוזיציה ביניהן                         | הפחתת כפילויות קוד במבני ירושה מרובעים (Matrix Inheritance)                              | גשר                  |
| Composite              | כשיש מבנה עץ של אובייקטים – וכל ענף/עלה מתנהג באותו אופן                                          | מחלקה שמכילה רשימה של אובייקטים מאותו סוג – `add()`, `remove()`                                | שימושי ב־UI, קבצים ותיקיות, ניהול היררכיות                                                | מרכיב (קומפוזיט)     |
| Decorator              | כשצריך להוסיף התנהגות לאובייקט בלי לשנות אותו                                                      | אובייקט אחד עוטף אובייקט אחר ומוסיף פונקציונליות                                                 | תומך בקומפוזיציה גמישה, נפוץ בפילטרים ב־Java Servlet                                      | מקשט                 |
| Facade                 | כשיש מערכת מורכבת שרוצים להסתיר את המורכבות שלה                                                    | מחלקה אחת שמכילה גישה לפונקציות רבות ומסתירה תהליכים פנימיים                                   | מיישר קו בין ממשקים מסובכים ומציג API פשוט                                                | חזית                 |
| Flyweight              | כשיש הרבה מופעים דומים ורוצים לחסוך בזיכרון                                                        | שימוש באובייקט משותף (cache) במקום ליצור עותקים                                                 | חשוב מאוד ב־Performance (למשל אובייקי גרפיקה חוזרים)                                      | משקל נוצה            |
| Proxy                  | כשצריך לשלוט על גישה לאובייקט אחר                                                                  | מחלקה שמבצעת לוגיקה לפני או אחרי גישה לאובייקט אחר                                              | משמש ל־Lazy Load, הרשאות, לוגים או גישה מרחוק                                             | פרוקסי (מתווך)       |
| Chain of Responsibility| כשיש שרשרת של מטפלים שיכולים לטפל בבקשה כלשהי                                                    | כל מטפל בודק אם הוא יכול לטפל, ואם לא – מעביר הלאה (`handler.setNext(...)`)                   | מפחית קוד תנאים מורכב ומחלק אחריות בין מחלקות                                            | שרשרת אחריות         |
| Command                | כשצריך להפוך פעולה לאובייקט עצמאי                                                                 | מחלקת `Command` עם `execute()` ואובייקט שמייצג פעולה                                             | תומך ב־Undo, תורים, וביצוע מאוחר (Deferred)                                               | פקודה                |
| Iterator               | כשצריך לעבור על קולקציה בלי לחשוף את המבנה שלה                                                     | `hasNext()`, `next()` – מחלקה חיצונית שמפעילה את הלולאה                                         | מפריד את הלוגיקה של המעבר מהמבנה הפנימי של הנתונים                                       | איטרטור              |
| Mediator               | כשיש ריבוי אובייקטים שמתקשרים – ורוצים לרכז את התקשורת במקום אחד                                 | מחלקת מתווך שמכילה הפניות בין רכיבים ומבצעת את השיחות ביניהם                                    | מפחית תלות הדדית ומוריד Coupling בין רכיבים                                              | מתווך                |
| Memento                | כשצריך לשמור מצב קודם של אובייקט בלי לחשוף את השדות שלו                                          | שימוש ב־saveState() ו־restoreState() לאובייקט                                                    | טוב ל־Undo, שמירה אוטומטית או גרסאות                                                     | מזכרת (זיכרון)       |
| Observer               | כשאובייקטים צריכים להתעדכן על שינוי באובייקט אחר                                                  | `subscribe()`, `notifyObservers()` – אובייקטים נרשמים ומקבלים עדכון                             | נפוץ במערכות UI, event-driven או Streams                                                  | צופה                 |
| State                  | כשאובייקט משנה את ההתנהגות שלו לפי מצב פנימי                                                      | הקוד מכיל מחלקות מצב נפרדות, וכל אחת משנה את ההתנהגות של האובייקט הראשי                       | מפחית תנאים פנימיים, מעביר אחריות למצבים                                                 | מצב                  |
| Strategy               | כשיש מספר דרכים לביצוע פעולה ורוצים לבחור אחת מהן בזמן ריצה                                      | מחלקות שונות שמממשות ממשק משותף (למשל PaymentStrategy)                                          | מאפשר הרחבה גמישה של אלגוריתמים                                                           | אסטרטגיה             |
| Template Method        | כשיש תהליך קבוע עם שלבים מסוימים שניתנים להתאמה                                                  | מחלקת אב עם מתודה שמכילה שלבים קבועים וממשק לשינוי חלק מהם במחלקות הבת                        | שומר על מבנה התהליך הכללי, מאפשר התאמות נקודתיות                                         | תבנית פעולה          |
| Visitor                | כשצריך להפעיל לוגיקה על עצמים מסוגים שונים בלי לשנות אותם                                        | מחלקת `Visitor` עם `visit()` שונים לכל סוג אובייקט                                               | מוסיף פונקציונליות ללא שינוי באובייקטים, מתאים למבני עץ                                  | מבקר                 |

<!-- DC_FOOTER_START -->
---

<div align="center">

✨ **Thank you for learning with Dvir Cabessa** ✨  
✨ **תודה שלמדתם עם דביר קבסה** ✨  

📘 *All Rights Reserved © Dvir Cabessa 2025*  
📘 *כל הזכויות שמורות © דביר קבסה 2025*  

🔗 *For educational purposes only – copying or distribution without permission is prohibited.*  
🔗 *החומר נועד לשימוש חינוכי בלבד — אין להעתיק או להפיץ ללא אישור.*

---

> _"Education is the art of awakening curiosity and guiding it toward creation."_  
> _"החינוך הוא אמנות המעירה את הסקרנות ומכוונת אותה ליצירה."_  
> — **Dvir Cabessa**

</div>
<!-- DC_FOOTER_END -->

