# 📘 ריקורסיה מול לולאות – Recursion vs. Iteration

## ✨ הסבר  
במבט ראשון, גם ריקורסיה וגם לולאות (`for`, `while`) משמשות אותנו כדי לבצע פעולות חוזרות.  
אבל אלו שתי **גישות שונות** מאוד – כל אחת עם היתרונות, החסרונות והשימושים שלה.

---

## ⚔️ הגדרה פורמלית

| מאפיין             | ריקורסיה                                   | לולאה                                  |
|---------------------|---------------------------------------------|----------------------------------------|
| אופן הפעולה         | פונקציה שקוראת לעצמה                      | חזרה על בלוק קוד לפי תנאי             |
| מבנה פנימי         | Call Stack (מחסנית קריאות)               | תנאי חזרה משתנה (`for`/`while`)       |
| שימוש בזיכרון       | גבוהה – כל קריאה מוסיפה frame             | חסכונית – משתנה משתנה בלוקלית         |
| בהירות הקריאה       | קרוב למבנה מתמטי/רעיוני                   | קרוב לחשיבה פרוצדורלית                |
| סיכון               | Stack Overflow (ללא base case)             | לולאה אינסופית (ללא תנאי עצירה)      |

---

## 🧪 אותה פונקציה – שתי דרכים

### סכום מ־1 עד n – ב־לולאה:
```python
def sum_iter(n):
    total = 0
    for i in range(1, n + 1):
        total += i
    return total
````

### סכום מ־1 עד n – בריקורסיה:

```python
def sum_rec(n):
    if n == 1:
        return 1
    return n + sum_rec(n - 1)
```

* שני הקודים מחזירים את אותה תוצאה – אבל דרך מחשבתית שונה לגמרי.

---

## 💡 מתי עדיף להשתמש בריקורסיה?

✅ כאשר הבעיה **מתפצלת לתתי־בעיות** – כמו עצים, תיקיות, גרפים, פרקטלים
✅ כאשר הקוד הרקורסיבי **ברור וקריא יותר** מלולאה
✅ כאשר יש תהליך שמזכיר הגדרה מתמטית רקורסיבית (כמו פיבונאצ'י, מגדלי האנוי)

---

## ⚠️ מתי *לא* להשתמש בריקורסיה?

❌ כאשר מספר הקריאות עלול להיות **מאוד גבוה** (למשל מעל 1000 קריאות)
❌ כאשר ניתן לפתור את הבעיה בלולאה פשוטה – ריקורסיה תהיה בזבזנית בזיכרון
❌ כאשר אין לך שליטה טובה על תנאי העצירה – הסיכון ל־Stack Overflow גבוה

---

## 🔍 ביצועים – מה באמת ההבדל?

| פעולה            | זמן ריצה  | זיכרון | קריאות               |
| ---------------- | --------- | ------ | -------------------- |
| `sum_iter(1000)` | מהיר מאוד | קבוע   | 0                    |
| `sum_rec(1000)`  | איטי יותר | 1000   | 1000 קריאות לפונקציה |

כלומר:

* **לולאות תמיד שומרות על צריכת זיכרון נמוכה**
* **ריקורסיה "צורכת" stack frame לכל קריאה**

---

## 📚 תרגול: מיון רקורסיבי מול איטרטיבי

### רקורסיבי – Merge Sort:

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(a, b):
    result = []
    while a and b:
        result.append(a.pop(0) if a[0] < b[0] else b.pop(0))
    return result + a + b
```

### איטרטיבי – Bubble Sort:

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

* Merge Sort הוא רקורסיבי אך יעיל מאוד (O(n log n))
* Bubble Sort איטרטיבי אך איטי מאוד (O(n²))

---

## 🧩 שאלות חשיבה

1. כתוב בעיה שניתן לפתור **גם** בלולאה **וגם** בריקורסיה – איזו דרך ברורה יותר?
2. תאר מקרה שבו ריקורסיה גרמה ל־`RecursionError`.
3. מתי עדיף לשלב בין השניים (למשל רקורסיה חלקית ולולאה פנימית)?
4. כיצד ניתן להפוך קוד רקורסיבי ללולאה (Iterative Rewrite)?
5. איך לדעת מה עדיף – ריקורסיה או לולאה?
