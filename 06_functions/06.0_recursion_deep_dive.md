<!-- DC_HEADER_START -->
<div align="center">

🐍 **Python Learning Series | סדרת לימודי פייתון**  
**Dvir Cabessa | דביר קבסה**  
© 2025 All Rights Reserved | כל הזכויות שמורות

</div>

---
<!-- DC_HEADER_END -->

# 📘 ריקורסיה – הסבר מעמיק (Deep Dive into Recursion)

## ✨ הסבר
ריקורסיה (Recursion) היא טכניקה בתכנות שבה פונקציה פותרת בעיה על ידי כך שהיא **קוראת לעצמה** – בדרך כלל על תת־בעיה קטנה יותר של אותה בעיה.

כדי להבין את זה לעומק, צריך לחשוב כמו מתמטיקאי:
- **בעיה גדולה** מחולקת לבעיה **קטנה יותר**
- ממשיכים כך עד שמגיעים למקרה פשוט – ה־**base case**
- אז מתחיל תהליך החזרה לאחור – כמו מגדל דומינו שמתמוטט מלמעלה למטה

## 🧠 מה באמת קורה מאחורי הקלעים?

### 🔁 כל קריאה לפונקציה יוצרת **Frame** חדש בזיכרון
בכל פעם שפונקציה קוראת לעצמה:
- נוצר עותק חדש שלה על ה־**call stack** (מחסנית הקריאות)
- היא מחכה שמה שהיא קראה לו יסיים, ורק אז ממשיכה
- כשהגענו ל־base case, מתחיל תהליך של "חזרה לאחור"

### 🔍 דוגמה מלאה – ספירת אחורה
```python
def count_down(n):
    print("Start of call:", n)
    if n == 0:
        print("Base case reached")
    else:
        count_down(n - 1)
    print("End of call:", n)
````

אם נריץ `count_down(3)`, סדר הפלט יהיה:

```
Start of call: 3
Start of call: 2
Start of call: 1
Start of call: 0
Base case reached
End of call: 0
End of call: 1
End of call: 2
End of call: 3
```

כלומר:

* הקריאות "נבנות" כלפי מטה
* ואז "נפרמות" כשהן חוזרות אחורה

---

## 🧠 מדוע צריך base case?

אם אין **מצב בסיס** ברור, הפונקציה תמשיך לקרוא לעצמה לנצח – עד שתיגמר מחסנית הקריאה (stack overflow).

לדוגמה:

```python
def endless():
    return endless()
```

תריץ את זה ותקבל שגיאת `RecursionError: maximum recursion depth exceeded`

---

## 🧠 מתמטית: פקטוריאל רקורסיבי

נוסחת הפקטוריאל (מתמטית):

* !n = n × (n−1) × (n−2) × ... × 1
* רקורסיבית:
  !n = n × !(n−1)
  עם תנאי עצירה: !0 = 1

קוד:

```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
```

---

## 📊 ריקורסיה לעומת לולאה

| נושא      | ריקורסיה                    | לולאה                        |
| --------- | --------------------------- | ---------------------------- |
| מבנה      | קריאה חוזרת לפונקציה        | חזרה בעזרת for / while       |
| זיכרון    | כל קריאה תופסת מקום ב־stack | לרוב חוסכת זיכרון            |
| מתי עדיף  | כשיש מבנה עץ, בעיה מתפצלת   | חישובים פשוטים וחוזרים       |
| קריאות    | איטי יותר – בגלל קריאות     | יעיל יותר                    |
| פשטות קוד | קוד קצר וברור               | לפעמים הקוד ארוך יותר        |
| סכנה      | Stack Overflow              | אינסופית רק בלולאה בלי עצירה |

---

## 🌲 מבני נתונים מתאימים לריקורסיה

ריקורסיה מתאימה במיוחד לבעיות שבהן:

* יש **מבנה עץ** (Tree) או גרף
* או כל בעיה שמתפצלת לתת־בעיות דומות

### דוגמה: מעבר על תיקיות

```python
def scan_folder(folder):
    for item in folder:
        if item.is_file():
            print(item.name)
        else:
            scan_folder(item)  # תיקיה פנימית = רקורסיה
```

---

## 🧠 מה זה Tail Recursion?

Tail Recursion = מצב שבו **הקריאה הרקורסיבית היא הפעולה האחרונה** שהפונקציה עושה.
בשפות אחרות (כמו Haskell או Scheme), זה מאפשר אופטימיזציה (TCO – Tail Call Optimization).
**ב־Python אין תמיכה מלאה ב־TCO**, ולכן זה פחות רלוונטי – אבל חשוב להכיר.

---

## 💡 טיפים מתקדמים

* לפני שמתחילים – הגדר מצב בסיס ברור (base case)
* ודא שהבעיה **מצטמצמת** בכל קריאה מחדש
* כדי לבדוק ריקורסיה – אפשר להדפיס `print()` בתחילת וסוף כל קריאה
* לפעמים כדאי להמיר ריקורסיה ללולאה – אם יש הרבה חזרות והביצועים חשובים
* אם יש הרבה חישובים כפולים – שקול להוסיף **memoization** (זיכרון ביניים)

---

## 🧠 כלים מתקדמים: Memoization

לפעמים ריקורסיה מחשבת שוב ושוב את אותם ערכים. נוכל להשתמש ב־**cache** כדי לשפר את הביצועים.

```python
from functools import lru_cache

@lru_cache()
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
```

---

## 🧩 שאלות עמוקות לבדיקה עצמית

1. מה ההבדל בין base case ל־recursive case?
2. האם כל בעיה ניתנת לפתרון על ידי ריקורסיה?
3. מדוע ריקורסיה יכולה להיות איטית יותר מלולאה?
4. האם אפשר לבצע מיון (כמו quicksort) בצורה רקורסיבית?
5. כתוב דוגמה לריקורסיה שבה יש שני מסלולי המשך ולא אחד.

<!-- DC_FOOTER_START -->
---

<div align="center">

✨ **Thank you for learning with Dvir Cabessa** ✨  
✨ **תודה שלמדתם עם דביר קבסה** ✨  

📘 *All Rights Reserved © Dvir Cabessa 2025*  
📘 *כל הזכויות שמורות © דביר קבסה 2025*  

🔗 *For educational purposes only – copying or distribution without permission is prohibited.*  
🔗 *החומר נועד לשימוש חינוכי בלבד — אין להעתיק או להפיץ ללא אישור.*

---

> _"Education is the art of awakening curiosity and guiding it toward creation."_  
> _"החינוך הוא אמנות המעירה את הסקרנות ומכוונת אותה ליצירה."_  
> — **Dvir Cabessa**

</div>
<!-- DC_FOOTER_END -->

