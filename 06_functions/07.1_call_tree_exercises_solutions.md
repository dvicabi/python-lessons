# 📘 תרגול – Tracing & Call Tree

## 🧪 תרגילים

1. עבור הפונקציה הבאה, צייר את עץ הקריאה עבור `f(3)`:

```python
def f(n):
    if n == 0:
        return
    f(n - 1)
    print(n)
````

2. כתבו פונקציה רקורסיבית שמקבלת מחרוזת ומדפיסה כל תו באותיות **מהאחרון לראשון**, כולל הדפסת tracing.

3. עבור הקוד הבא – כתבו מה יודפס בפועל כאשר קוראים `foo(2)`:

```python
def foo(n):
    print("Start", n)
    if n > 0:
        foo(n - 1)
    print("End", n)
```

4. כתבו פונקציה שמדפיסה את קריאות הרקורסיה שלה בהזחה (indent) – עבור כל שלב בקריאה.

5. ציירו עץ קריאה עבור `fibonacci(3)` כולל ערכים מחושבים.

## 📌 הוראות

* ניתן להשתמש בפלט או בהדפסות להסביר שלבי קריאה.
* הקפידו על הזחה בהתאם לעומק הקריאה.
* הדמיה גרפית באותיות או הדפסות מתקבלות.


# 📘 פתרונות – Tracing & Call Tree

## 🧪 פתרונות

### תרגיל 1 – עץ הקריאה עבור f(3)

````

f(3)
└── f(2)
└── f(1)
└── f(0)

```

פלט:
```

1
2
3

````

### תרגיל 2 – הדפסת מחרוזת הפוך עם Tracing
```python
def reverse_trace(s, depth=0):
    indent = "  " * depth
    if s == "":
        print(indent + "End")
        return
    print(indent + f"Call with: {s}")
    reverse_trace(s[1:], depth + 1)
    print(indent + f"Returning: {s[0]}")
````

### תרגיל 3 – פלט עבור foo(2)

```
Start 2
Start 1
Start 0
End 0
End 1
End 2
```

### תרגיל 4 – הדפסת הקריאות עם הזחה

```python
def trace(n, depth=0):
    print("  " * depth + f"trace({n})")
    if n == 0:
        return
    trace(n - 1, depth + 1)
```

### תרגיל 5 – עץ הקריאה של fibonacci(3)

```
fib(3)
├── fib(2)
│   ├── fib(1) → 1
│   └── fib(0) → 0
└── fib(1) → 1
```

פלט כולל ערכים:

```
fib(3) = fib(2) + fib(1)
       = (fib(1) + fib(0)) + 1
       = (1 + 0) + 1 = 2
```

````

---

📂 `06_recursion/06.1c_recursion_vs_iteration_exercises.md`  
📂 `06_recursion/06.2c_recursion_vs_iteration_solutions.md`  
**(השוואה ריקורסיה מול לולאה)**

```markdown
# 📘 תרגול – Recursion vs. Iteration

## 🧪 תרגילים

1. כתבו שתי פונקציות שמחזירות את סכום מספרים מ־1 עד n: אחת באיטרציה, אחת ברקורסיה.

2. כתבו מימוש של `power(a, b)` שמחזיר `aⁿ` – גם ברקורסיה וגם בלולאה.

3. מה ההבדל בין שימוש בלולאה לרקורסיה כאשר רוצים לבדוק אם מספר מופיע ברשימה?

4. עבור הפונקציה הרקורסיבית של חיפוש איבר ברשימה – כתבו את המקבילה האיטרטיבית.

5. נתונה רקורסיה שמדפיסה את המספרים מ־n ל־0 – המירו אותה ללולאה תוך שמירה על סדר הפלט.

## 📌 הוראות
- כתבו את שתי הגרסאות זו לצד זו (rec/iter).
- אין להשתמש ב־sum() או פונקציות מובנות אחרות.
- ציינו מתי כל גישה עדיפה ולמה.
````

---

````markdown
# 📘 פתרונות – Recursion vs. Iteration

## 🧪 פתרונות

### תרגיל 1 – סכום מ־1 עד n
```python
def sum_rec(n):
    if n == 1:
        return 1
    return n + sum_rec(n - 1)

def sum_iter(n):
    total = 0
    for i in range(1, n + 1):
        total += i
    return total
````

### תרגיל 2 – חזקת מספר (a^b)

```python
def power_rec(a, b):
    if b == 0:
        return 1
    return a * power_rec(a, b - 1)

def power_iter(a, b):
    result = 1
    for _ in range(b):
        result *= a
    return result
```

### תרגיל 3 – חיפוש איבר ברשימה

```python
def find_rec(lst, x):
    if not lst:
        return False
    if lst[0] == x:
        return True
    return find_rec(lst[1:], x)

def find_iter(lst, x):
    for item in lst:
        if item == x:
            return True
    return False
```

### תרגיל 4 – המרה של חיפוש

> נכלל בתרגיל 3 – שתי הגרסאות מוצגות זו לצד זו.

### תרגיל 5 – המרה של הדפסה מ־n ל־0

```python
def print_rec(n):
    if n < 0:
        return
    print(n)
    print_rec(n - 1)

def print_iter(n):
    while n >= 0:
        print(n)
        n -= 1
```
